name: Release Codes Database

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Version tag for the release (e.g., v1.0.0)'
        required: true
        default: 'v1.0.0'

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Set up Docker
      uses: docker/setup-buildx-action@v3

    - name: Prepare output directory
      run: mkdir -p output && chmod -R 777 output
    
    - name: Fix script permissions
      run: chmod +x scripts/*.sh

    - name: Build Docker images
      run: docker compose up --build --detach

    - name: Wait for PostgreSQL initialization and dump creation
      shell: bash 
      run: |
        echo "Waiting for PostgreSQL to initialize and create dump..."
        timeout_seconds=600 # 10 minutes timeout (adjust if your init script takes longer)
        interval_seconds=10 # Check every 10 seconds
        elapsed_seconds=0
        
        # Default Docker Compose project name is the directory name, e.g., 'registry-codes'
        # So the container name is likely 'registry-codes-postgres-1' or similar.
        # We'll use a label selector for more robustness if project name changes in compose.
        postgres_container_label="com.docker.compose.service=postgres"

        until docker logs --tail 50 "$(docker ps -q --filter "label=${postgres_container_label}")" 2>&1 | grep -q -m 1 "Done! Database dump created at /output/registry_codes.dump"; do
          elapsed_seconds=$((elapsed_seconds + interval_seconds))
          if [ $elapsed_seconds -ge $timeout_seconds ]; then
            echo "Timeout: PostgreSQL dump creation message not found within $timeout_seconds seconds."
            echo "Current PostgreSQL logs:"
            docker logs "$(docker ps -q --filter "label=${postgres_container_label}")"
            docker compose down # Attempt cleanup
            exit 1
          fi
          echo "Still waiting for PostgreSQL dump... ($elapsed_seconds s elapsed)"
          # Check if the container is still running
          if ! docker ps -q --filter "label=${postgres_container_label}" --filter "status=running" | grep -q .; then
             echo "PostgreSQL container is not running. Aborting."
             echo "Current PostgreSQL logs (attempting to get logs from stopped container):"
             # Try to get logs from a potentially stopped container if possible
             docker logs "$(docker ps -aq --filter "label=${postgres_container_label}" | head -n1)" || echo "Could not retrieve logs for stopped container."
             docker compose down
             exit 1
          fi
          sleep $interval_seconds
        done
        
        echo "PostgreSQL dump created!"

    - name: Stop container
      run: docker compose down

    - name: Verify output files
      run: ls -la output/
      
    - name: Get tag name
      id: get_tag
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          echo "TAG_NAME=${{ github.event.inputs.tag_name }}" >> $GITHUB_ENV
        else
          echo "TAG_NAME=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV
        fi
    
    - name: Create release notes
      run: |
        echo "# Registry Codes Database Release ${{ env.TAG_NAME }}" > release_notes.md
        echo "" >> release_notes.md
        echo "Generated on $(date)" >> release_notes.md
        echo "" >> release_notes.md
        echo "## Contents" >> release_notes.md
        echo "" >> release_notes.md
        echo "- **registry_codes.sqlite**: SQLite database file with all registry codes" >> release_notes.md
        echo "- **registry_codes.dump**: PostgreSQL SQL dump file with all registry codes" >> release_notes.md
        echo "" >> release_notes.md
        echo "## Download Examples" >> release_notes.md
        echo "" >> release_notes.md
        echo "### SQLite Database" >> release_notes.md
        echo "" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "# Download with curl" >> release_notes.md
        echo "curl -L -o registry_codes.sqlite https://github.com/renalreg/registry-codes/releases/download/${{ env.TAG_NAME }}/registry_codes.sqlite" >> release_notes.md
        echo "" >> release_notes.md
        echo "# Use the database" >> release_notes.md
        echo "sqlite3 registry_codes.sqlite 'SELECT * FROM modality_codes LIMIT 5;'" >> release_notes.md
        echo '```' >> release_notes.md
        echo "" >> release_notes.md
        echo "### PostgreSQL Dump" >> release_notes.md
        echo "" >> release_notes.md
        echo '```bash' >> release_notes.md
        echo "# Download with curl" >> release_notes.md
        echo "curl -L -o registry_codes.dump https://github.com/renalreg/registry-codes/releases/download/${{ env.TAG_NAME }}/registry_codes.dump" >> release_notes.md
        echo "" >> release_notes.md
        echo "# Restore to a PostgreSQL database" >> release_notes.md
        echo "psql -U postgres -d your_database_name -f registry_codes.dump" >> release_notes.md
        echo '```' >> release_notes.md
        echo "" >> release_notes.md

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ env.TAG_NAME }}
        name: Registry Codes ${{ env.TAG_NAME }}
        body_path: release_notes.md
        draft: true
        files: |
          output/registry_codes.sqlite
          output/registry_codes_ods.sqlite
          output/registry_codes.dump
        fail_on_unmatched_files: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
